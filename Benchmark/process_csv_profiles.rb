# This script parses CSV files generated by nvprof using the following command:
#     nvprof --csv -u ms --print-gpu-trace --log-file trace_gpu_1%p \
#         --profile-all-processes
# Specifically, this looks for any instances of kernel co-scheduling. For each
# log, it will print the percentage of kernels that had *some* overlap with
# another log.

# TODO (next): Don't calculate overlap based on file, but based on kernels!

# Returns a dict mapping file name -> array of kernel runs. The array of kernel
# runs consists of a list of times in the following order:
# [start time, duration, kernel name].
def load_trace_files(directory)
  trace_files = Dir[directory + "/trace_gpu_*"]
  to_return = {}
  trace_files.each do |filename|
    content = []
    File.open(filename, 'rb') {|f| content = f.read.split(/\n+/)}
    content.map! {|line| line.strip}
    content.delete_if {|line| line =~ /^==/}
    content.delete_if {|line| line =~ /^\s*$/}
    kernel_runs = []
    content.each do |line|
      # Get rid of argument lists, the commas in them break our simple parsing
      line.gsub!(/\([^)]*,[^)]*\)/, "()")
      cols = line.split(/,/)
      next if cols.size < 3
      next if cols[0] =~ /"/
      name = cols[-1].gsub(/"/, "")
      # We'll ignore memcpy times for now
      next if name =~ /\[CUDA memcpy/
      start_time = cols[0].to_f
      duration = cols[1].to_f
      kernel_runs << [start_time, duration, name]
    end
    next if kernel_runs.size == 0
    # Ensure each list is sorted by start time.
    to_return[filename] = kernel_runs.sort {|a, b| a[0] <=> b[0]}
  end
  to_return
end

# Takes a file's array of runtimes and returns a dict separating runtimes by
# kernel name.
def separate_trace_by_kernel(file_data)
  to_return = {}
  file_data.each do |d|
    to_return[d[2]] = [] if !to_return.include?(d[2])
    to_return[d[2]] << [d[0], d[1]]
  end
  to_return
end

# Takes the data returned by load_trace_files. For the given key, calculates
# the percentage of kernels which were overlapped by some kernel in one of the
# other logs. Returns a percentage, between 0.0 and 100.0.
def get_kernel_overlap_percentage(all_data, key)
  kernels = all_data[key]
  overlapped = 0
  kernels.each do |kernel|
    start_time = kernel[0]
    end_time = kernel[0] + kernel[1]
    all_data.each do |filename, values|
      # Make sure not to compare the key of interest to itself.
      next if filename == key
      overlap_found = false
      values.each do |value|
        # All values are in sorted order, so we can stop looking at this list
        # if we're at a time that starts after the key we care about.
        break if value[0] > end_time
        value_end_time = value[0] + value[1]
        next if value_end_time < start_time
        overlap_found = true
        break
      end
      if overlap_found
        # If we've already seen overlap with one kernel, don't look for another
        overlapped += 1
        break
      end
    end
  end
  ((overlapped.to_f) / kernels.size.to_f) * 100.0
end

def print_overlapped_percentages(directory)
  data = load_trace_files(directory)
  data.each_key do |k|
    percentage = get_kernel_overlap_percentage(data, k)
    sample_kernel = data[k][2]
    puts "File %s: %f%% overlap. (Contains kernels such as %s)" %
      [k, percentage, sample_kernel]
  end
end

if ARGV.size < 1
  puts "Usage: ruby #{__FILE__} <directory containing CSV nvprof files>"
  exit 1
end
directory = ARGV[0]

print_overlapped_percentages(directory)
